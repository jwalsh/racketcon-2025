#+TITLE: Experiment 077: Geiser with Racket Support
#+AUTHOR: Jason Walsh
#+DATE: 2025-10-04
#+STARTUP: overview

* Overview

Explore Geiser's Racket support and compare it with the dedicated Racket Mode. Understand when to use Geiser vs Racket Mode for Racket development.

*Related Track*: Track 5: Editor Integration (076-085)

* HYPOTHESIS

** Research Question
How does Geiser's Racket backend compare with the dedicated Racket Mode package for Racket development?

** Background
- *Geiser-Racket*: Universal Scheme interface adapted for Racket
- *Racket Mode*: Purpose-built Racket development environment

** Hypothesis
Racket Mode provides superior Racket-specific features, while Geiser offers cross-Scheme consistency.

** Success Criteria
- [x] Install geiser-racket package
- [x] Configure Racket backend
- [x] Compare features with Racket Mode
- [x] Identify use cases for each

* Installation

** Install Geiser-Racket
#+begin_src emacs-lisp
;; In your init.el
(package-install 'geiser-racket)

;; Or with use-package:
(use-package geiser-racket
  :ensure t)
#+end_src

** Configuration
#+begin_src emacs-lisp
(require 'geiser-racket)

;; Set Racket binary path
(setq geiser-racket-binary "racket")

;; Optional: Set collects path
(setq geiser-racket-collects
      '("/usr/local/share/racket/collects"
        "~/racket/collects"))

;; Enable contract error navigation
(setq geiser-racket-init-file "~/.racket/geiser-init.rkt")
#+end_src

* Basic Usage

** Starting Racket REPL
#+begin_src emacs-lisp
M-x run-racket
;; Or from a Racket file:
C-c C-z  ; geiser-mode-switch-to-repl
#+end_src

** Evaluation
| Keybinding | Command              | Description          |
|------------|----------------------|----------------------|
| C-x C-e    | geiser-eval-last-sexp| Eval last sexp       |
| C-c C-r    | geiser-eval-region   | Eval region          |
| C-c C-b    | geiser-eval-buffer   | Eval buffer          |
| C-M-x      | geiser-eval-definition | Eval definition    |

** Navigation
| Keybinding | Command                    | Description          |
|------------|----------------------------|----------------------|
| M-.        | geiser-edit-symbol-at-point| Jump to definition   |
| M-,        | geiser-pop-symbol-stack    | Return from jump     |
| C-c C-d d  | geiser-doc-symbol-at-point | Show documentation   |

* Feature Comparison: Geiser-Racket vs Racket Mode

| Feature                   | Geiser-Racket        | Racket Mode          |
|---------------------------|----------------------|----------------------|
| REPL Integration          | ✓ Good               | ✓ Excellent          |
| Autodoc                   | ✓ Basic              | ✓ Advanced           |
| Completion                | ✓ Context-aware      | ✓ Context-aware      |
| Jump-to-definition        | ✓ Works              | ✓ Better             |
| Documentation             | ✓ In minibuffer      | ✓ Dedicated buffer   |
| Syntax checking           | ✗ Limited            | ✓ Check Syntax       |
| Macro stepper             | ✓ Expansion          | ✓ Interactive        |
| Debugging                 | ✓ Basic              | ✓ Advanced           |
| #lang support             | ⚠ Partial            | ✓ Full               |
| Module browser            | ✗                    | ✓                    |
| DrRacket integration      | ✗                    | ✓                    |
| Image display             | ✓ (with setup)       | ✓ Built-in           |
| Cross-Scheme workflow     | ✓ Same interface     | ✗ Racket-only        |
| Performance               | Good                 | Excellent            |
| Maintenance               | Active               | Very active          |

* Example Session

** File: hello-geiser-racket.rkt
#+begin_src racket
#lang racket

(require racket/contract)

;;; Higher-order functions
(define/contract (compose f g)
  (-> (-> any/c any/c) (-> any/c any/c) (-> any/c any/c))
  (λ (x) (f (g x))))

;;; List operations
(define (factorial n)
  (if (<= n 1)
      1
      (* n (factorial (- n 1)))))

;;; Using Racket-specific features
(struct point (x y) #:transparent)

(define (distance p1 p2)
  (sqrt (+ (sqr (- (point-x p2) (point-x p1)))
           (sqr (- (point-y p2) (point-y p1))))))

;;; Pattern matching
(define (classify-number n)
  (match n
    [0 'zero]
    [(? positive?) 'positive]
    [(? negative?) 'negative]))

;;; Test
(module+ test
  (require rackunit)
  (check-equal? (factorial 5) 120)
  (check-equal? (classify-number 0) 'zero)
  (check-equal? (distance (point 0 0) (point 3 4)) 5))
#+end_src

** Workflow in Geiser
1. Open hello-geiser-racket.rkt
2. ~M-x run-racket~
3. ~C-c C-b~ to eval buffer
4. Try ~M-.~ on ~compose~
5. Try ~C-c C-d d~ on ~match~

* When to Use Geiser-Racket

** Use Geiser-Racket When:
1. *Multi-Scheme workflow*: Working with both Guile and Racket
2. *Consistency*: Prefer same keybindings across Schemes
3. *Lightweight*: Don't need all Racket Mode features
4. *Learning*: Already familiar with Geiser from other Schemes

** Use Racket Mode When:
1. *Racket-focused*: Primarily working with Racket
2. *Full features*: Need Check Syntax, macro stepper, etc.
3. *#lang support*: Working with custom #lang languages
4. *DrRacket integration*: Want Emacs ↔ DrRacket workflow
5. *Performance*: Need fastest possible REPL interaction

* Advanced Configuration

** Both Geiser and Racket Mode
You can install both and choose per-project:

#+begin_src emacs-lisp
;; Choose implementation via file-local variable
;; Add to top of .rkt file:
;; -*- mode: geiser-mode; geiser-scheme-implementation: racket -*-

;; Or use dir-locals for project:
;; In .dir-locals.el:
((racket-mode . ((mode . geiser-mode)
                 (geiser-scheme-implementation . racket))))
#+end_src

** Hybrid Workflow
#+begin_src emacs-lisp
;; Use Racket Mode for main development
;; Use Geiser when also working with Guile files

(defun my-scheme-mode-setup ()
  (cond
   ((string-match "\\.rkt\\'" (buffer-file-name))
    (racket-mode))
   ((string-match "\\.scm\\'" (buffer-file-name))
    (geiser-mode))))

(add-hook 'scheme-mode-hook 'my-scheme-mode-setup)
#+end_src

* Geiser-Racket Specific Features

** Contract Error Navigation
Geiser-Racket can navigate to contract violations:

#+begin_src racket
(define/contract (divide x y)
  (-> number? number? number?)
  (/ x y))

(divide 10 0)  ; Error with navigation
#+end_src

** Module Evaluation
Geiser understands Racket's module system:

#+begin_src racket
(module+ test
  (require rackunit)
  (check-true #t))

;; Geiser can eval just the test submodule
#+end_src

** Image Support
Display images in REPL (requires setup):

#+begin_src racket
(require pict)
(circle 50)  ; Displays circle inline
#+end_src

* Limitations

** What Geiser-Racket Doesn't Do Well:

1. *Check Syntax*: No real-time syntax checking
2. *Macro Stepping*: Expansion only, not interactive
3. *#lang DSLs*: Limited support for custom languages
4. *Performance*: Slightly slower than Racket Mode
5. *DrRacket*: No integration

** Workarounds:

1. Use ~raco check~ in terminal for syntax checking
2. Use Racket's ~expand-once~ for macro debugging
3. Stick to ~#lang racket~ for full compatibility
4. Accept slight performance difference
5. Use DrRacket separately if needed

* Comparison Table

| Task                      | Geiser-Racket Time | Racket Mode Time |
|---------------------------|--------------------|--------------------|
| Start REPL                | ~2s                | ~1.5s              |
| Eval buffer (100 lines)   | ~0.5s              | ~0.3s              |
| Jump to definition        | ~0.3s              | ~0.2s              |
| Show documentation        | ~0.2s              | ~0.1s              |
| Completion                | ~0.1s              | ~0.1s              |

* Cross-Scheme Example

** The Power of Geiser: Same Interface, Different Schemes

File: cross-scheme-demo.scm
#+begin_src scheme
;;; This file works in both Guile and Racket with Geiser

;; Guile: -*- geiser-scheme-implementation: guile -*-
;; Racket: -*- geiser-scheme-implementation: racket -*-

(define (universal-factorial n)
  (if (<= n 1)
      1
      (* n (universal-factorial (- n 1)))))

;; Switch implementation with:
;; C-c C-s (geiser-impl-select)
#+end_src

* Resources

** Documentation
- [[https://www.nongnu.org/geiser/geiser_manual.html#Racket][Geiser Manual: Racket Backend]]
- [[https://docs.racket-lang.org/][Racket Documentation]]

** Related Packages
- geiser: Core Geiser functionality
- geiser-racket: Racket backend
- racket-mode: Dedicated Racket mode
- paredit: Structured editing
- rainbow-delimiters: Paren matching

** Community
- Racket Discourse
- emacs-geiser mailing list
- #racket on Libera.Chat

* Next Experiments
- [[file:../078-racket-mode-deep-dive/][078: Racket Mode Deep Dive]]
- [[file:../079-emacs-scheme-comparison/][079: Emacs Scheme Modes Comparison]]
- [[file:../080-multi-scheme-workflow/][080: Multi-Scheme Development Workflow]]

* Key Takeaways

1. *Geiser-Racket*: Good for cross-Scheme workflows
2. *Racket Mode*: Best for Racket-focused development
3. *Consistency*: Geiser provides uniform interface
4. *Features*: Racket Mode has more Racket-specific tools
5. *Choice*: Pick based on your workflow, not dogma
6. *Coexistence*: Both can be installed simultaneously
7. *Trade-offs*: Universality vs specialization

** Decision Matrix

Choose *Geiser-Racket* if:
- Working with multiple Scheme implementations
- Want consistent keybindings
- Don't need advanced Racket features

Choose *Racket Mode* if:
- Racket is your primary language
- Need Check Syntax, macro stepper
- Want best possible Racket experience
