#+TITLE: Amazon Ion Data Format
#+AUTHOR: RacketCon 2025
#+DATE: 2025-10-04

* Introduction

Amazon Ion is a richly-typed, self-describing data format that is a superset of JSON.

* Key Features

** 1. Self-Describing

Ion data is self-describing - no external schema required:

#+begin_src ion
// The data itself describes its structure and types
{
  name: "Alice",
  age: 30,
  balance: 1234.56,
  created: 2025-10-04T12:00:00Z
}
#+end_src

** 2. Rich Type System

Beyond JSON's limited types:

| JSON Type | Ion Types |
|-----------+-----------|
| null | null (with type annotations) |
| boolean | bool |
| number | int, decimal, float |
| string | string, symbol, timestamp |
| - | blob, clob |
| array | list |
| object | struct, sexp |

** 3. Binary and Text Formats

- Text format: Human-readable (like JSON)
- Binary format: Compact, efficient parsing

** 4. Annotations

Add metadata to values:

#+begin_src ion
// Annotate a string with type information
user::"alice@example.com"

// Multiple annotations
authenticated::verified::"alice@example.com"

// Annotations on any value
dollars::123.45
cents::12345
#+end_src

* Ion vs JSON

** JSON Example

#+begin_src json
{
  "name": "Alice",
  "age": 30,
  "email": "alice@example.com",
  "balance": 1234.56,
  "created": "2025-10-04T12:00:00Z"
}
#+end_src

** Equivalent Ion

#+begin_src ion
{
  name: "Alice",
  age: 30,
  email: user::"alice@example.com",      // Annotated
  balance: dollars::1234.56,              // Annotated
  created: 2025-10-04T12:00:00Z          // Native timestamp
}
#+end_src

* Ion Type Details

** Null Type

#+begin_src ion
null                  // Generic null
null.int              // Typed null
null.string           // Typed null
#+end_src

** Numbers

#+begin_src ion
// Integers (arbitrary precision)
42
-17
0

// Decimals (arbitrary precision)
3.14
-0.001
1.23e-4

// Floats (IEEE 754)
3.14e0
+inf
-inf
nan
#+end_src

** Timestamps

#+begin_src ion
// Full precision
2025-10-04T12:30:45.123Z

// Date only
2025-10-04

// With timezone
2025-10-04T12:30:45-05:00
#+end_src

** Strings and Symbols

#+begin_src ion
// String (quoted)
"Hello, world!"
"Multi-line\nstring"

// Symbol (unquoted identifier)
name
first_name
'quoted symbol'
#+end_src

** Binary Data

#+begin_src ion
// Blob (binary large object)
{{aGVsbG8=}}           // Base64 encoded

// Clob (character large object)
{{"This is a clob"}}
#+end_src

** Lists

#+begin_src ion
// List (ordered)
[1, 2, 3]
["Alice", "Bob", "Carol"]
[
  {name: "Alice", age: 30},
  {name: "Bob", age: 25}
]
#+end_src

** Structs

#+begin_src ion
// Struct (like JSON object)
{
  name: "Alice",
  age: 30,
  email: "alice@example.com"
}

// Field names are symbols
{
  'field name with spaces': "value"
}
#+end_src

** S-Expressions

#+begin_src ion
// S-expression (Lisp-like)
(+ 1 2 3)
(cons 'a 'b)
(list 1 2 3)
#+end_src

* Annotations in Depth

** Purpose

Annotations add semantic information without changing structure:

#+begin_src ion
// Same structure, different meanings
metric::123.45        // Metric system
imperial::123.45      // Imperial system

// Domain-specific types
email::"alice@example.com"
phone::"+1-555-0123"
ssn::"123-45-6789"
#+end_src

** Multiple Annotations

#+begin_src ion
// Stack annotations left to right
verified::user::email::"alice@example.com"

// Read as: verified (user (email "alice@example.com"))
#+end_src

** Structural Annotations

#+begin_src ion
// Annotate entire structures
person::{
  name: "Alice",
  age: 30
}

validated::user_input::[1, 2, 3]
#+end_src

* Ion in Amazon Systems

** Use Cases

1. *Retail Systems*
   - Product catalogs
   - Order processing
   - Inventory management

2. *Consumer Products*
   - Device configuration
   - Service APIs
   - Data synchronization

3. *Internal Tools*
   - Analytics pipelines
   - Data processing
   - Workflow definitions

** Why Ion at Amazon?

- *Schema Evolution*: Add fields without breaking existing code
- *Rich Types*: Express domain concepts directly
- *Efficiency*: Binary format for storage/transmission
- *Flexibility*: Annotations for semantic metadata

* Ion vs Other Formats

| Feature | JSON | Protobuf | Avro | Ion |
|---------+------+----------+------+-----|
| Self-describing | ✓ | ✗ | ✗ | ✓ |
| Rich types | ✗ | ✓ | ✓ | ✓ |
| Binary format | ✗ | ✓ | ✓ | ✓ |
| Text format | ✓ | ✗ | ✗ | ✓ |
| Annotations | ✗ | ✗ | ✗ | ✓ |
| Schema required | ✗ | ✓ | ✓ | ✗ |

* Practical Examples

** Configuration File

#+begin_src ion
// Application configuration
app_config::{
  version: "1.2.3",

  database: {
    host: "localhost",
    port: 5432,
    timeout: seconds::30
  },

  features: enabled::[
    "analytics",
    "caching"
  ],

  release_date: 2025-10-04
}
#+end_src

** API Response

#+begin_src ion
// REST API response
api_response::{
  status: ok::200,

  data: {
    user_id: uuid::"550e8400-e29b-41d4-a716-446655440000",
    name: "Alice",
    created: 2025-01-15T10:30:00Z,
    balance: usd::1234.56
  },

  metadata: {
    request_id: "req-12345",
    timestamp: 2025-10-04T12:00:00Z
  }
}
#+end_src

** Event Stream

#+begin_src ion
// Event log entries
[
  event::{
    type: user_login,
    timestamp: 2025-10-04T12:00:00Z,
    user_id: "alice",
    ip: ipv4::"192.168.1.1"
  },

  event::{
    type: purchase,
    timestamp: 2025-10-04T12:05:00Z,
    user_id: "alice",
    amount: usd::99.99,
    items: [
      {sku: "ITEM-001", qty: 2},
      {sku: "ITEM-042", qty: 1}
    ]
  }
]
#+end_src

* Ion Fusion Connection

Ion Fusion leverages these Ion features:

1. *Self-describing*: Code and data share format
2. *Annotations*: Add semantics to data/code
3. *Rich types*: Express domain concepts
4. *S-expressions*: Natural for Lisp-like code

This enables **data/code unification** - the core of Ion Fusion!

* Resources

- [[https://amazon-ion.github.io/ion-docs/][Ion Documentation]]
- [[https://github.com/amazon-ion/ion-specification][Ion Specification]]
- [[https://github.com/amazon-ion][Ion Libraries]]

* Next Steps

See [[file:03-fusion-concepts.org][Ion Fusion Concepts]] to understand how this format enables unified data/code semantics.
