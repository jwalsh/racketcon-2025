* Experiment 002: Formal Methods Overview

** Overview

Survey of formal methods techniques and tools for software verification. Understanding the landscape helps contextualize Rosette's solver-aided programming approach.

** What Are Formal Methods?

Formal methods are mathematically rigorous techniques for:
- Specifying software behavior
- Verifying correctness properties
- Finding bugs automatically
- Synthesizing correct-by-construction code

** Classification of Approaches

*** 1. Theorem Proving (Interactive)
- *Examples*: Coq, Isabelle/HOL, Agda, Lean
- *Approach*: Manual proof construction with tool assistance
- *Strengths*: Can prove deep properties, handles complex mathematics
- *Challenges*: Requires expertise, time-intensive

*** 2. Model Checking
- *Examples*: TLA+, SPIN, Alloy
- *Approach*: Exhaustive state space exploration
- *Strengths*: Fully automatic, finds counterexamples
- *Challenges*: State explosion, limited to finite models

*** 3. SMT-Based Verification
- *Examples*: Rosette, Dafny, F*
- *Approach*: Translate verification conditions to SMT solver
- *Strengths*: Automatic, good for bounded verification
- *Challenges*: Decidability limits, performance

*** 4. Abstract Interpretation
- *Examples*: Astr√©e, Polyspace
- *Approach*: Over-approximate program behavior
- *Strengths*: Scales to large code, sound
- *Challenges*: False positives, imprecise

** Comparison Table

| Tool/System | Type | Automation | Domain | Learning Curve |
|-------------+------+------------+--------+----------------|
| Rosette | SMT-based | High | General programs | Medium |
| TLA+ | Model checking | High | Distributed systems | Medium |
| Lean | Theorem proving | Low | Mathematics/programs | High |
| Dafny | SMT-based | Medium | Sequential programs | Medium |
| Alloy | Model checking | High | System design | Low-Medium |
| Coq | Theorem proving | Low | Mathematics/programs | High |

** Use Cases by Domain

*** Distributed Systems
- *TLA+*: Protocol verification (AWS, Microsoft)
- *Rosette*: DNS policy verification (Cloudflare)

*** Cryptography
- *F\star*: Cryptographic implementations (HACL\star)
- *EasyCrypt*: Cryptographic proofs

*** Compilers
- *Coq*: CompCert verified C compiler
- *Lean*: Mathlib formalization

*** System Programming
- *Dafny*: Correct-by-construction code
- *Rosette*: Synthesizing systems code

** Rosette's Niche

Rosette occupies a unique space:
- *Solver-aided programming*: Embed verification in the language
- *Lightweight*: No separate specification language
- *Flexible*: Verification, synthesis, debugging
- *Racket integration*: Full language features + solving

** Example Scenarios

*** Scenario 1: Verify Protocol
- *TLA+*: Specify state machine, check invariants
- *Rosette*: Encode protocol logic, verify properties symbolically

*** Scenario 2: Synthesize Implementation
- *Rosette*: Best choice - direct synthesis from specs
- *Lean*: Would require manual construction

*** Scenario 3: Prove Mathematical Theorem
- *Lean/Coq*: Best choice - rich proof libraries
- *Rosette*: Limited to decidable fragments

** Resources

*** Books
- "Formal Reasoning About Programs" (Chlipala)
- "Practical TLA+" (Lamport)
- "Software Foundations" (Pierce et al.)

*** Papers
- "Growing Solver-Aided Languages with Rosette" (Torlak & Bodik)
- "Formal Specification and Verification of TCP Extended Open" (TLA+)
- "The Lean Theorem Prover" (Moura et al.)

*** Online
- [[https://docs.racket-lang.org/rosette-guide/][Rosette Guide]]
- [[https://learntla.com/][Learn TLA+]]
- [[https://leanprover-community.github.io/][Lean Community]]
